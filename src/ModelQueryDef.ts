import { DerivedFieldDef } from "./DerivedFieldDef";
import type { EnumDef } from "./EnumDef";
import { type BaseFieldConfig, FieldDef } from "./FieldDef";
import type { ModelDef } from "./ModelDef";
import { ModelFieldDef } from "./ModelFieldDef";
import type { ObjectBaseDef } from "./ObjectBaseDef";
import { List, Nullable, deriveTrueType } from "./Types";
import { String, Uint } from "./scalars";
import { ObjectDef } from "./ObjectDef";

type QueryableModelType =
    | ModelDef
    // | PaginatedModelDef
    ;

/**
 * Defines a resolver that will start a new aggregate query and/or add a stage
 * to the current aggregate query for a specific Model type.
 */
export class ModelQueryFieldDef extends FieldDef {

    public override readonly isDtoOnly = true;
    public override readonly isReadonly = true;

    private searchKey?: string;
    private sortKey?: string;
    private paginated?: boolean;

    constructor(config: ModelQueryFieldConfig) {
        super(config.name, config.model, config.desc);

        if (config.searchable) this.searchKey = "search";
        if (config.sortable) this.sortKey = "sort";
        this.paginated = config.paginated;
    }

    /** Performs type expansion and prepartion if necessary. */
    public override prepare(ctx: BuildCtx, parent: ObjectBaseDef): void {
        const model = deriveTrueType(this.type) as ModelDef;

        // make sure the model was prepared first, since we need some of
        // the types generated by its prepare method
        ctx.prepare(model);

        // TODO: is this a one-to-one query? or is many involved?

        const fields = Object.values(model.fields)
            .filter(f => f instanceof ModelFieldDef || f instanceof DerivedFieldDef);

        const hasSearchableFields = fields.some(f => "isSearchable" in f && f.isSearchable);
        if (this.searchKey && hasSearchableFields) {
            this.args[this.searchKey] = {
                type: String,
                desc: "Searches for objects with the given text.",
            };
        }

        const sortEnum = ctx.types[`${model.name}SortField`] as EnumDef;

        if (this.sortKey && sortEnum) {
            this.args[this.sortKey] = {
                type: new Nullable(new List(sortEnum)),
                desc: "Sorts the results by the given fields.",
                // TODO: default value
            };
        }

        const paginate = this.paginated ?? parent.name === "Query";

        if (paginate) {
            const pagination = ctx.config.pagination;

            // create the connection object
            let connObj = ctx.types[`${model.name}Connection`] as ObjectDef;
            if (!connObj) {
                connObj = new ObjectDef(
                    `${model.name}Connection`,
                    `Connection for ${model.name} objects.`,
                );
                connObj.field({
                    name: "nodes",
                    type: new List(model),
                    desc: "The results of the query.",
                });
                connObj.field({
                    name: "pageInfo",
                    type: ctx.types["PageInfo"] as ObjectDef,
                    desc: "Information about the current page of results.",
                });
                ctx.types[connObj.name] = connObj;
                ctx.prepare(connObj);
            }

            // add pagination arguments
            switch (pagination.type) {
                case "page":
                    this.args[pagination.pageArgName ?? "page"] = {
                        type: new Nullable(Uint),
                        desc: "The page number to return.",
                        // default:
                    };
                    this.args[pagination.perPageArgName ?? "perPage"] = {
                        type: new Nullable(Uint),
                        desc: "The number of items to return per page.",
                        // default:
                    };
                    break;
                case "cursor":
                    this.args["first"] = {
                        type: new Nullable(Uint),
                        desc: "The number of items to return.",
                        // default:
                    };
                    this.args["after"] = {
                        type: new Nullable(String),
                        desc: "The cursor to start after.",
                        // default:
                    };
                    break;
                case "offset":
                    this.args["offset"] = {
                        type: new Nullable(Uint),
                        desc: "The number of items to skip.",
                        // default:
                    };
                    this.args["limit"] = {
                        type: new Nullable(Uint),
                        desc: "The number of items to return.",
                        // default:
                    };
                    break;
            }
        }

    }

    public override getApiField(ctx: BuildCtx, parent: ObjectBaseDef) {
        const field = super.getApiField(ctx, parent);
        if (!field) return null;

        // intercept the field and change the return type to the appropriate version
        // based on the query type
        const paginate = this.paginated ?? parent.name === "Query";
        if (paginate) {
            const model = deriveTrueType(this.type) as ModelDef;
            const connObj = ctx.types[`${model.name}Connection`] as ObjectDef;
            if (!connObj) throw new Error(`Cannot find connection object for model '${model.name}'`);

            field.type = connObj.toGqlType();
        }

        return field;
    }

    public override getResolverImpl(ctx: BuildCtx, parent: ObjectBaseDef) {
        // TODO: this is to be replaced by the aggregate query system, this is
        //       just placeholder to allow for a working solution

        const model = deriveTrueType(this.type) as ModelDef;
        const dbkey = `db`;
        const isMany = true; // TODO: support one-to-one queries

        // TODO: does the user have a custom resolver for this in their codebase?
        // TODO: does the user have middleware for this in their codebase?

        let out = `async (src, args, context, info) => {\n`;
        out += `const db = context.${dbkey}.collection("${model.collection}");\n`;

        if (isMany) {

            // out += `const query = db.aggregate(_buildQuery(info));\n`;

            out += `const query = db.aggregate([\n`;

            out += `]);\n`;

            if (this.paginated ?? parent.name === "Query") {
                out += `const [result] = await query.toArray();\n`;
            } else {
                out += `const result = await query.toArray();\n`;
            }

        } else {
            out += `const result = await db.findOne({\n`;
            out += `});\n`;
        }


        out += `return result;\n`;
        out += `}`;
        return out;
    }

    public override getQueryRules(ctx: BuildCtx, parent: ObjectBaseDef): null | ObjectInfoTable[string][string] {
        const model = deriveTrueType(this.type) as ModelDef;
        return {
            collection: model.collection,
        };
    }

}


export interface ModelQueryFieldConfig extends Omit<BaseFieldConfig, "type"> {
    /** Name of the query field created. */
    name: string;
    /** Description of the query field. */
    desc?: string;
    /** Is this is a paginated query? */
    paginated?: boolean;
    /** Allow searching of the results. */
    searchable?: boolean;
    /** Allow sorting of the results. */
    sortable?: boolean;
    /** The model type to query. */
    model: ModelDef | (() => ModelDef);
}